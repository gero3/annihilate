<!DOCTYPE html>
<html>

<head>
  <title></title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      margin: 0px;
      background-color: #000000;
      overflow: hidden;
      color: #fff;
    }
  </style>
  <script src="./lib/three.js/build/three.min.js"></script>

</head>

<body>
</body>
<script type="module">
  import { World } from './lib/ecsy.module.js';
  import { Object3D, Collidable, Collider, Recovering, Moving, PulsatingScale, Timeout, PulsatingColor, Colliding, Rotating, PlayerControl, CAction } from './components.js';
  import { RotatingSystem, ColliderSystem, PulsatingColorSystem, PulsatingScaleSystem, MovingSystem, TimeoutSystem, PlayerControlSystem } from './systems.js';
  import { GLTFLoader } from "./lib/three.js/examples/jsm/loaders/GLTFLoader.js"

  window.okey = {} //object of keyboard
  var world = new World();
  var entity;
  window.isMounted = false;

  world
    .registerComponent(Object3D)
    .registerComponent(Collidable)
    .registerComponent(Collider)
    .registerComponent(Recovering)
    .registerComponent(Moving)
    .registerComponent(PulsatingScale)
    .registerComponent(Timeout)
    .registerComponent(PulsatingColor)
    .registerComponent(Colliding)
    .registerComponent(Rotating)
    .registerComponent(PlayerControl)
    .registerComponent(CAction)

  world
    .registerSystem(RotatingSystem)
    .registerSystem(PulsatingColorSystem)
    .registerSystem(PulsatingScaleSystem)
    .registerSystem(TimeoutSystem)
    .registerSystem(ColliderSystem)
    .registerSystem(MovingSystem)
    .registerSystem(PlayerControlSystem)

  var scene, renderer, parent;
  var clock = new THREE.Clock();

  init();

  function randomSpherePoint(radius) {
    var u = Math.random();
    var v = Math.random();
    var theta = 2 * Math.PI * u;
    var phi = Math.acos(2 * v - 1);
    var x = radius * Math.sin(phi) * Math.cos(theta);
    var y = radius * Math.sin(phi) * Math.sin(theta);
    var z = radius * Math.cos(phi);
    return new THREE.Vector3(x, y, z);
  }

  var objMoving, states;
  function init() {
    var numObjects = 10;
    var size = 0.2;
    var w = 100;

    scene = new THREE.Scene();

    window.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 100);
    camera.position.set(0, 30, 30)
    camera.lookAt(0, 0, 0)
    entity = world.createEntity()
    entity.addComponent(PlayerControl)
    entity.addComponent(Object3D, { object: camera })

    parent = new THREE.Object3D();


    var geometry = new THREE.IcosahedronGeometry(1);
    var material = new THREE.MeshStandardMaterial({ color: '#ff0' });
    var parent2 = new THREE.Object3D();

    objMoving = new THREE.Mesh(geometry, material);
    objMoving.position.set(0, 0, 0);
    var radius = 10;

    entity = world.createEntity();
    objMoving.position.set(0, 0, radius);
    entity.addComponent(Collider);
    entity.addComponent(Object3D, { object: objMoving });

    entity = world.createEntity();
    parent2.add(objMoving);
    entity.addComponent(Rotating, { rotatingSpeed: 0.5 })
      .addComponent(Object3D, { object: parent2 });
    parent.add(parent2);

    states = [];

    var ambientLight = new THREE.AmbientLight(0xcccccc);
    scene.add(ambientLight);

    var directionalLight = new THREE.DirectionalLight(0xffffff, 2);
    directionalLight.position.set(1, 1, 0.5).normalize();
    scene.add(directionalLight);

    var geometry = new THREE.BoxBufferGeometry(size, size, size);

    for (var i = 0; i < numObjects; i++) {

      var material = new THREE.MeshStandardMaterial({ color: new THREE.Color(1, 0, 0) });
      var mesh = new THREE.Mesh(geometry, material);
      mesh.position.copy(randomSpherePoint(radius));

      var state = {
        mesh: mesh,
        colliding: false,
        rotationSpeed: 0,
        originalColor: material.color.clone(),
        tmpColor: new THREE.Color()
      };

      states.push(state);

      var entity = world.createEntity();
      entity.addComponent(Object3D, { object: mesh });
      entity.addComponent(PulsatingColor, { offset: i });
      entity.addComponent(PulsatingScale, { offset: i });

      if (Math.random() > 0.5) {
        entity.addComponent(Moving, { offset: i });
      }

      entity.addComponent(Collidable);
      parent.add(mesh);
    }

    scene.add(parent);

    /*role*/{
      let entity = world.createEntity()
      entity.addComponent(PlayerControl)
      new Promise((resolve, reject) => {
        var loader = new GLTFLoader();
        loader.load('./model/fel_lord/a.glb', function (gltf) {
          // console.log(gltf)
          window.role = gltf.scene

          role.traverse(function (child) {
            if (child.isMesh) {
              child.material = new THREE.MeshBasicMaterial()
              child.material.map = new THREE.TextureLoader().load('./model/fel_lord/fel_lord.png')
              child.material.map.flipY = false
              child.material.skinning = true
            }
          });
          scene.add(role)
          entity.addComponent(Object3D, { object: role })
          // role.scale.set(.7,.7,.7)
          // role.position.set(x,y,z)
          window.mixerRole = new THREE.AnimationMixer(role)
          let oaction = {}
          gltf.animations.forEach(animation => {
            let name = animation.name.toLowerCase()
            let action = mixerRole.clipAction(animation)
            oaction[name] = action
            if (['jump', 'punch', 'dodge', 'hit'].includes(name)) {
              action.loop = THREE.LoopOnce
            }
            // if ([].includes(name)) {
            //   action.loop = THREE.LoopOnce
            //   action.clampWhenFinished = true
            // }
          })
          // console.log(oaction)
          let action_act = oaction.idle
          action_act.play()
          entity.addComponent(CAction, { oaction, action_act })
          mixerRole.addEventListener('finished', e => {
            oaction.idle.play()
            entity.getMutableComponent(CAction).action_act = oaction.idle
          })
          resolve()
          isMounted = true
        }, undefined, function (e) {
          console.error(e);
          reject()
        });
      })
    }

    /*ground*/{
      let mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x999999, /*depthWrite: false*/ }));
      mesh.rotation.x = - Math.PI / 2;
      scene.add(mesh);


      let grid = new THREE.GridHelper(200, 40, 0x000000, 0x000000);
      grid.position.y = .1
      grid.material.opacity = 0.2;
      grid.material.transparent = true;
      scene.add(grid);
    }

    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0x333333);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.gammaOutput = true;
    renderer.gammaFactor = 1.3;
    document.body.appendChild(renderer.domElement);
    //
    window.addEventListener('resize', onWindowResize, false);

    window.addEventListener('keydown', e => {
      // console.log(e)
      // console.log(e.key)
      okey[e.key] = true
    })
    window.addEventListener('keyup', e => {
      // console.log(e)
      okey[e.key] = false
    })

    renderer.setAnimationLoop(animate);

  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    if (!isMounted) return;
    var delta = clock.getDelta();
    var elapsedTime = clock.elapsedTime;
    //console.time('render');
    world.execute(delta, elapsedTime);
    mixerRole.update(delta)
    //console.timeEnd('render');

    renderer.render(scene, camera);
  }
</script>

</html>