<!DOCTYPE html>
<html>

<head>
  <title></title>
  <meta name="description" content="">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <style>
    body {
      margin: 0px;
      background-color: #000000;
      overflow: hidden;
      color: #fff;
    }
  </style>
  <script src="./lib/three.js/build/three.min.js"></script>
  <script src="./lib/cannon.js"></script>
  <script src="./lib/CannonDebugRenderer.js"></script>

</head>

<body>
</body>
<script type="module">
  import { World } from './lib/ecsy.module.js';
  import { CObject3D, CCollidable, CCollider, CRecovering, CMoving, CPulsatingScale, CTimeout, CPulsatingColor, CColliding, CRotating, CPlayerControl, CAction } from './components.js';
  import { SRotating, SCollider, SPulsatingColor, SPulsatingScale, SMoving, STimeout, SPlayerControl } from './systems.js';
  import { GLTFLoader } from "./lib/three.js/examples/jsm/loaders/GLTFLoader.js"

  window.okey = {} //object of keyboard
  var world = new World();
  var entity;

  world
    .registerComponent(CObject3D)
    .registerComponent(CCollidable)
    .registerComponent(CCollider)
    .registerComponent(CRecovering)
    .registerComponent(CMoving)
    .registerComponent(CPulsatingScale)
    .registerComponent(CTimeout)
    .registerComponent(CPulsatingColor)
    .registerComponent(CColliding)
    .registerComponent(CRotating)
    .registerComponent(CPlayerControl)
    .registerComponent(CAction)

  world
    .registerSystem(SRotating)
    .registerSystem(SPulsatingColor)
    .registerSystem(SPulsatingScale)
    .registerSystem(STimeout)
    .registerSystem(SCollider)
    .registerSystem(SMoving)
    .registerSystem(SPlayerControl)

  var scene, renderer, parent;
  var clock = new THREE.Clock();

  init_cannon();
  init();

  function randomSpherePoint(radius) {
    var u = Math.random();
    var v = Math.random();
    var theta = 2 * Math.PI * u;
    var phi = Math.acos(2 * v - 1);
    var x = radius * Math.sin(phi) * Math.cos(theta);
    var y = radius * Math.sin(phi) * Math.sin(theta);
    var z = radius * Math.cos(phi);
    return new THREE.Vector3(x, y, z);
  }

  async function init() {
    var numObjects = 10;
    var size = 0.2;
    var w = 100;

    scene = new THREE.Scene();

    window.cameraBiasZ = 30
    window.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.25, 100);
    camera.position.set(0, 30, cameraBiasZ)
    camera.lookAt(0, 0, 0)

    /*lights*/{
      let light = new THREE.HemisphereLight(0xffffff, 0x444444);
      light.position.set(0, 20, 0);
      scene.add(light);

      light = new THREE.DirectionalLight(0xffffff);
      light.position.set(0, 20, 10);
      scene.add(light);
    }

    /*role*/{
      let velocity = new THREE.Vector3()
      let facing = new THREE.Vector2()
      let entity = world.createEntity()
      window.roleEntity = entity
      entity.addComponent(CPlayerControl)
      entity.addComponent(CMoving, { velocity, facing })

      let body_size = 1.5
      let body = new CANNON.Body({
        mass: 1,
      })
      // let shape=new CANNON.Sphere(body_size)
      let shape = new CANNON.Cylinder(body_size, body_size, 3, 8)
      body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      body.angularDamping = 1
      body.addShape(shape)
      body.position.set(0, 5, 0)
      cannonWorld.addBody(body)

      await new Promise((resolve, reject) => {
        var loader = new GLTFLoader();
        loader.load('./model/fel_lord/a.glb', function (gltf) {
          // console.log(gltf)
          window.role = gltf.scene

          role.traverse(function (child) {
            if (child.isMesh) {
              child.material = new THREE.MeshBasicMaterial()
              child.material.map = new THREE.TextureLoader().load('./model/fel_lord/fel_lord.png')
              child.material.map.flipY = false
              child.material.skinning = true
            }
          });
          scene.add(role)
          entity.addComponent(CObject3D, { object: role, body, body_size })
          // role.scale.set(.7,.7,.7)
          // role.position.set(x,y,z)
          window.mixerRole = new THREE.AnimationMixer(role)
          let oaction = {}
          window.oactionRole = oaction
          gltf.animations.forEach(animation => {
            let name = animation.name.toLowerCase()
            let action = mixerRole.clipAction(animation)
            oaction[name] = action
            if (['jump', 'punch', 'dodge', 'hit'].includes(name)) {
              action.loop = THREE.LoopOnce
            }
            // if ([].includes(name)) {
            //   action.loop = THREE.LoopOnce
            //   action.clampWhenFinished = true
            // }
          })
          // console.log(oaction)
          let action_act = oaction.idle
          action_act.play()
          entity.addComponent(CAction, { oaction, action_act })
          mixerRole.addEventListener('finished', e => {
            oaction.idle.play()
            entity.getMutableComponent(CAction).action_act = oaction.idle
            entity.addComponent(CMoving, { velocity, facing })
          })
          resolve()
        }, undefined, function (e) {
          console.error(e);
          reject()
        });
      })
    }

    /*enemy*/{
      let velocity = new THREE.Vector3()
      let facing = new THREE.Vector2()
      let entity = world.createEntity()
      window.enemyEntity = entity
      entity.addComponent(CMoving, { velocity, facing })

      let body_size = 1.5
      let body = new CANNON.Body({
        mass: 1,
      })
      // let shape=new CANNON.Sphere(body_size)
      let shape = new CANNON.Cylinder(body_size, body_size, 3, 8)
      body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      body.angularDamping = 1
      body.addShape(shape)
      body.position.set(15, 5, -15)
      cannonWorld.addBody(body)

      await new Promise((resolve, reject) => {
        var loader = new GLTFLoader();
        loader.load('./model/RobotExpressive/RobotExpressive.glb', function (gltf) {
          // console.log(gltf)
          window.enemy = gltf.scene
          enemy.scale.setScalar(.7)
          scene.add(enemy)
          entity.addComponent(CObject3D, { object: enemy, body, body_size })
          // enemy.scale.set(.7,.7,.7)
          // enemy.position.set(x,y,z)
          window.mixerEnemy = new THREE.AnimationMixer(enemy)
          let oaction = {}
          gltf.animations.forEach(animation => {
            let name = animation.name.toLowerCase()
            let action = mixerEnemy.clipAction(animation)
            oaction[name] = action
            if (['jump', 'punch', 'dance'].includes(name)) {
              action.loop = THREE.LoopOnce
            }
            if (['death'].includes(name)) {
              action.loop = THREE.LoopOnce
              action.clampWhenFinished = true
            }
            oaction.dance.timeScale = 3
          })
          // console.log(oaction)
          let action_act = oaction.idle
          action_act.play()
          entity.addComponent(CAction, { oaction, action_act })
          mixerEnemy.addEventListener('finished', e => {
            oaction.idle.play()
            entity.getMutableComponent(CAction).action_act = oaction.idle
          })
          resolve()
        }, undefined, function (e) {
          console.error(e);
          reject()
        });
      })
    }

    /*ground*/{
      let mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000), new THREE.MeshPhongMaterial({ color: 0x999999, /*depthWrite: false*/ }));
      mesh.rotation.x = - Math.PI / 2;
      scene.add(mesh);

      let grid = new THREE.GridHelper(200, 40, 0x000000, 0x000000);
      grid.position.y = .1
      grid.material.opacity = 0.2;
      grid.material.transparent = true;
      scene.add(grid);

      let shape = new CANNON.Plane()
      let body = new CANNON.Body({
        mass: 0,
        collisionResponse: 0,
      })
      body.addShape(shape)
      body.position.set(0, 0, 0)
      body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
      // body.addEventListener("collide", function (event) {
      //   console.log('collide floor')
      // })
      cannonWorld.addBody(body)
    }

    renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0x333333);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.gammaOutput = true;
    renderer.gammaFactor = 1.3;
    document.body.appendChild(renderer.domElement);
    //
    window.addEventListener('resize', onWindowResize, false);

    window.addEventListener('keydown', e => {
      // console.log(e)
      // console.log(e.key)
      okey[e.key] = true
    })
    window.addEventListener('keyup', e => {
      // console.log(e)
      okey[e.key] = false
    })

    window.cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, cannonWorld);
    renderer.setAnimationLoop(animate);

  }

  function init_cannon() {
    window.fixedTimeStep = 1 / 60;
    window.maxSubSteps = 3;
    window.cannonWorld = new CANNON.World()
    cannonWorld.defaultContactMaterial.friction = 100
    cannonWorld.gravity.set(0, -50, 0)
    cannonWorld.broadphase = new CANNON.NaiveBroadphase();
  }

  function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  function animate() {
    var delta = clock.getDelta();
    var elapsedTime = clock.elapsedTime;
    //console.time('render');
    world.execute(delta, elapsedTime);
    mixerRole.update(delta)
    camera.position.x = role.position.x
    camera.position.z = role.position.z + cameraBiasZ

    cannonDebugRenderer.update()
    cannonWorld.step(fixedTimeStep, delta)

    //console.timeEnd('render');

    renderer.render(scene, camera);
  }
</script>

</html>